Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 

You can design retransmission of RUDP based on time-out only. Selective ACKs and/or cumulative ACKs can be used to report missing datagrams to the sender. 

How do we simulate a lost packet and test the reliability? There are several possible ways to do it:
 Use mininet, run
$ sudo mn --link tc,delay='10ms',loss=5,max_queue_size=20 -x
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.

You can use a random generator to drop random packets in your own implementation. You can do predictable drops at either the sender or the receiver. For instance, the sender can skip sending a datagram every N datagram, in which N is a parameter adjustable to users, and the receiver can drop ACKs in a similar manner. Your program should report (#max_sequence_number/N) retransmissions. 

You are not required to implement a sender or receiver in a multi-threaded way. You can simply use one thread for tasks back-to-back. A possible back-to-back workflow of the sender is charted for you.


Task 1: Design and Setup
The best way to approach this project is in incremental steps. Do not try to implement all of the functionality at once.
First,Project 2 (15%): Reliable UDP
CS488 Spring 2021
Due: Two milestone deadlines, see the submission instructions
Overview
You will design and implement a simple select repeat(SR) protocol on top of UDP to guarantee the reliability of one-way transmission of UDP datagrams. You will transfer a large file on top of your reliable UDP from one host to another with some lossy link in between as a good proof-of-concept to verify your one-way transmission work. Large teams are required to do more experiments on the window sizes and RTO estimates.
Group
General Requirements
Task 1: Design and Setup
Task 2: Implement selective repeat algorithm
Task 3:  Throughput [Large teams only]
Submission Instructions
Learning Outcomes
After completing this programming assignment, students should be able to:
Understand how sliding window controls the flow of packets between two hosts. 
Learn the principles behind GBN and SR protocols. 
Build a more reliable UDP by designing and implementing a SR protocol on top of UDP

Group
You can work in a group of maximum 4 students. Workload could vary depending on the size of your team. In the following table, X represents the task is mandatory for the team based on its size. Only one submission is required from a group.  There are no extra credits if small teams decide to pursue optional tasks on their own.
  Workload
w.r.t.
Size

Size
Task 1 

(30%)
Task 2

(35%)
Task 3

(35%)

Small Team
1-2 students
X
X


Large Team
3-4 students
X
X
X



General Requirements
You can use Python, C or Java in this project. If you choose other languages, you may not get as much support from the community or from the class. 

You don't have to implement any error detection. In fact, UDP has built-in error-detection. 

You can design your own RUDP datagram format, including header and payload. However, your design must include at least sequence number and data. Let us synchronize on terminologies. 

In your RUDP layer, data is transferred as datagrams instead of packets in the rest of context, for the sake of consistency with UDP protocol. In other words, the application data are broken down into many pieces of data, and each piece of data is encapsulated with a RUDP header as a RUDP datagram, and RUDP datagrams are then passed to the UDP layer. Please note there is a recommendation to the maximum UDP datagram size in order to eliminate the fragmentation effect from IP/physical layers. Please consider having RUDP datagram less than 1400 bytes because most ethernet networks support 1500 bytes MSS. 

All implementations should be written in sockets. No high-level network-layer abstractions are allowed in this project. You are allowed to use some high-level abstractions for parts that are not directly related to networking, such as string parsing, multi-threading, circular queues (to implement buffers).

You can design and implement your own timer and time-out. Suppose your sender is waiting for ACKs from the receiver. 
A very simple way to implement a timer is to set your sender socket as non-blocking, then the sender does not block on receiving from the socket. If the server receives an ACK then the timer of the acked datagram is reset. If the server receives -1 (which means no data) then timers of all un-acked datagrams are incremented, and compared against the threshold of timeout predefined by you. If the timer is greater than the threshold, then the datagram is timed out and to be resent. 
If you decide to set your server blocking on recv from socket, then you may use select or epoll to check the arrival of packets. 
Each RUDP datagram in the buffer should have a timer, but the timer should not be part of RUDP datagram structure (why?). 
This creates a minimal network topology with two hosts connected to a switch with 10ms latency on each link, 5% packet loss on each link, and a buffer of size 20. Note that there is no space between parameters.
